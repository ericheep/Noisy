//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chugerate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"

// general includes
#include <stdio.h>
#include <limits.h>
#ifdef WIN32
#define _USE_MATH_DEFINES
#endif
#include <math.h>

// declaration of chugin constructor
CK_DLL_CTOR(noisy_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(noisy_dtor);

// noisy member functions
CK_DLL_MFUN(noisy_generate);

// set type of noise
CK_DLL_MFUN(noisy_setBlack);
CK_DLL_MFUN(noisy_setBrown);
CK_DLL_MFUN(noisy_setGaussian);
CK_DLL_MFUN(noisy_setGray);
CK_DLL_MFUN(noisy_setRed);

// for Chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK(noisy_tick);

// this is a special offset reserved for Chugin internal data
t_CKINT noisy_data_offset = 0;


class NoiseFunc
{
public:
    virtual float generate() = 0;
};


class BlackFunc: public NoiseFunc
{
public:
    BlackFunc() {
        m = 0;
    }

    float generate() {
        return 0;
    }

private:
    float m;
};


class GaussianFunc : public NoiseFunc
{
public:
    GaussianFunc(float _mu, float _sigma) {
        mu = _mu;
        sigma = _sigma;
        epsilon = std::numeric_limits<double>::min();
        two_pi = 2.0 * M_PI;

        z0 = 0.0;
        z1 = 0.0;

        u1 = 0.0;
        u2 = 0.0;
    }

    float generate() {
        can_generate = !can_generate;

        if (!can_generate)
           return z1 * sigma + mu;
        do
         {
           u1 = rand() * (1.0 / RAND_MAX);
           u2 = rand() * (1.0 / RAND_MAX);
         }
        while ( u1 <= epsilon );

        z0 = sqrt(-2.0 * log(u1)) * cos(two_pi * u2);
        z1 = sqrt(-2.0 * log(u1)) * sin(two_pi * u2);

        return z0 * sigma + mu;
    }

private:
    float mu, sigma;

    float two_pi;
    double epsilon;

    double z0, z1;
    bool can_generate;

    double u1, u2;
};

class GrayFunc : public NoiseFunc
{
public:
    GrayFunc() {
    }

    float generate() {
        return 0;
    }

private:
};

class RedFunc : public NoiseFunc
{
public:
    RedFunc(float _r) {
        r = _r;
    }

    float generate() {
        return 0;
    }

private:
    float r;
};

/*
while (true)
{
  float  r = white();
  m_brown += r;
  if (m_brown<-8.0f || m_brown>8.0f) m_brown -= r;
  else break;
}
return m_brown*0.0625f;
*/

class BrownFunc : public NoiseFunc
{
public:
    BrownFunc() {
        brown = 0.0;
    }

    float generate() {
        while (true) {
            white = rand() * ((1.0 / RAND_MAX) * 2.0) - 1.0;
            brown += white;
            if (brown < -8.0 || brown > 8.0) {
                brown -= white;
            }
            else {
                break;
            }
        }
        return brown * 0.0625;
    }

private:
    float m_brown, white;
};

class WhiteFunc : public NoiseFunc
{
public:
    WhiteFunc() {
    }

    float generate() {
       return rand() * ((1.0 / RAND_MAX) * 2.0) - 1.0;
    }
private:
    // nothing
};

// class definition for internal Chugin data
class Noisy
{
public:
    // constructor
    Noisy( t_CKFLOAT fs)
    {
        m_func = new GaussianFunc(0.0, 1.0);
    }

    NoiseFunc* m_func;

    // for Chugins extending UGen
    SAMPLE tick( SAMPLE in )
    {
        in = m_func->generate();
        return in;
    }

    void setBlack()
    {
        m_func = new BlackFunc();
    }

    void setBrown()
    {
        m_func = new BrownFunc();
    }

    void setGaussian( t_CKFLOAT mu, t_CKFLOAT sigma )
    {
        m_func = new GaussianFunc(mu, sigma);
    }

    void setGray()
    {
        m_func = new GrayFunc();
    }

    void setRed( t_CKFLOAT r )
    {
        m_func = new RedFunc(r);
    }


private:
    // instance data
};


// query function: chuck calls this when loading the Chugin
CK_DLL_QUERY( Noisy )
{
    QUERY->setname(QUERY, "Noisy");

    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "Noisy", "UGen");

    // register the constructor
    QUERY->add_ctor(QUERY, noisy_ctor);
    // register the destructor
    QUERY->add_dtor(QUERY, noisy_dtor);

    // for UGen's only: add tick function
    QUERY->add_ugen_func(QUERY, noisy_tick, NULL, 1, 1);

    QUERY->add_mfun(QUERY, noisy_setBlack, "void", "setBlack");
    QUERY->doc_func(QUERY, "Set Black Noise.");

    QUERY->add_mfun(QUERY, noisy_setBrown, "void", "setBrown");
    QUERY->doc_func(QUERY, "Set Brown Noise.");

    QUERY->add_mfun(QUERY, noisy_setGaussian, "void", "setGaussian");
    QUERY->add_arg(QUERY, "float", "mu");
    QUERY->add_arg(QUERY, "float", "sigma");
    QUERY->doc_func(QUERY, "Set Guassian White Noise with mu and sigma value.");

    QUERY->add_mfun(QUERY, noisy_setGray, "void", "setGray");
    QUERY->doc_func(QUERY, "Set Gray Noise.");

    QUERY->add_mfun(QUERY, noisy_setRed, "void", "setRed");
    QUERY->doc_func(QUERY, "Set Red Noise with r value.");

    // this reserves a variable in the ChucK internal class to store
    // referene to the c++ class we defined above
    noisy_data_offset = QUERY->add_mvar(QUERY, "int", "@n_data", false);

    // end the class definition
    QUERY->end_class(QUERY);

    return TRUE;
}


// implementation for the constructor
CK_DLL_CTOR(noisy_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, noisy_data_offset) = 0;

    // instantiate our internal c++ class representation
    Noisy * n_obj = new Noisy(API->vm->get_srate());

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, noisy_data_offset) = (t_CKINT) n_obj;
}


// implementation for the destructor
CK_DLL_DTOR(noisy_dtor)
{
    // get our c++ class pointer
    Noisy * n_obj = (Noisy *) OBJ_MEMBER_INT(SELF, noisy_data_offset);
    // check it
    if( n_obj )
    {
        // clean up
        delete n_obj;
        OBJ_MEMBER_INT(SELF, noisy_data_offset) = 0;
        n_obj = NULL;
    }
}


// implementation for tick function
CK_DLL_TICK(noisy_tick)
{
    // get our c++ class pointer
    Noisy * n_obj = (Noisy *) OBJ_MEMBER_INT(SELF, noisy_data_offset);

    // invoke our tick function; store in the magical out variable
    if(n_obj) *out = n_obj->tick(in);

    return TRUE;
}

CK_DLL_MFUN(noisy_setBlack)
{
    Noisy * n_obj = (Noisy *) OBJ_MEMBER_INT(SELF, noisy_data_offset);
    n_obj->setBlack();
}

CK_DLL_MFUN(noisy_setGaussian)
{
    Noisy * n_obj = (Noisy *) OBJ_MEMBER_INT(SELF, noisy_data_offset);
    t_CKFLOAT a0 = GET_NEXT_FLOAT(ARGS);
    t_CKFLOAT a1 = GET_NEXT_FLOAT(ARGS);
    n_obj->setGaussian(a0, a1);
}

CK_DLL_MFUN(noisy_setGray)
{
    Noisy * n_obj = (Noisy *) OBJ_MEMBER_INT(SELF, noisy_data_offset);
    n_obj->setGray();
}

CK_DLL_MFUN(noisy_setRed)
{
    Noisy * n_obj = (Noisy *) OBJ_MEMBER_INT(SELF, noisy_data_offset);
    n_obj->setRed(GET_NEXT_FLOAT(ARGS));
}

CK_DLL_MFUN(noisy_setBrown)
{
    Noisy * n_obj = (Noisy *) OBJ_MEMBER_INT(SELF, noisy_data_offset);
    n_obj->setBrown();
}
